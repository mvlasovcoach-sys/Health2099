<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Map snapshots</title>
    <meta name="theme-color" content="#2563eb" />
    <link rel="manifest" href="./manifest.webmanifest" />
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      integrity="sha256-o9N1j7kGStpBlXnKzHf0C6YxM0tZQYVI0eCFj0zPmL0="
      crossorigin="anonymous"
      onerror="this.onerror=null;this.href='./shared/vendor/leaflet/leaflet.css';"
    />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
    <link rel="stylesheet" href="./shared/styles.css" />
    <style>
      body {
        background: #0f172a;
      }
      .app-shell {
        background-image: none;
        background: radial-gradient(circle at top, rgba(15, 23, 42, 0.96), rgba(2, 6, 23, 0.9));
      }
      .map {
        width: 100%;
        min-height: 420px;
        height: 60vh;
        border-radius: 16px;
        overflow: hidden;
      }
    </style>
  </head>
  <body class="app-shell">
    <div data-include="nav"></div>
    <main class="app-main">
      <div class="container flow">
        <header class="page-header">
          <span class="page-header__eyebrow">Map</span>
          <h1>Location snapshots</h1>
          <p>Capture manual or device-based locations to build a private map of your wellbeing journey. Everything stays offline and stored locally.</p>
          <span class="badge">Local only</span>
        </header>

        <div class="map-layout">
          <aside class="map-sidebar">
            <section class="map-card">
              <h2 style="margin:0; font-size:1.1rem; color:var(--color-heading);">Controls</h2>
              <div class="map-toolbar">
                <button type="button" id="my-location">My location</button>
                <button type="button" id="snapshot">Snapshot</button>
                <button type="button" id="date-button" class="secondary">Date ⌄</button>
                <button type="button" class="secondary map-mode" id="show-day" data-mode="day" aria-pressed="true">Day</button>
                <button type="button" class="secondary map-mode" id="show-week" data-mode="week" aria-pressed="false">Week</button>
                <button type="button" class="secondary map-mode" id="show-month" data-mode="month" aria-pressed="false">Month</button>
                <label for="search-note" class="visually-hidden">Search by note</label>
                <input type="search" id="search-note" placeholder="Search by note" autocomplete="off" />
                <span class="map-toolbar__spacer" aria-hidden="true"></span>
                <button type="button" class="secondary" id="export-map">Export JSON</button>
                <button type="button" class="secondary" id="import-map">Import JSON</button>
              </div>
              <input type="date" id="date-input" class="visually-hidden" />
              <input type="file" id="import-file" accept="application/json" class="visually-hidden" />
              <p class="map-selected-range" id="range-label"></p>
            </section>

            <section class="map-card">
              <div class="map-calendar" aria-label="Snapshot calendar">
                <div class="map-calendar__header">
                  <button type="button" class="ghost" id="calendar-prev" aria-label="Previous month">‹</button>
                  <div class="map-calendar__month" id="calendar-month"></div>
                  <button type="button" class="ghost" id="calendar-next" aria-label="Next month">›</button>
                </div>
                <div class="map-calendar__grid map-calendar__grid--labels" aria-hidden="true"></div>
                <div class="map-calendar__grid" id="calendar-grid" role="grid" aria-labelledby="calendar-month"></div>
              </div>
              <h2 style="margin:0; font-size:1.1rem; color:var(--color-heading);">History</h2>
              <div id="history-count" class="tag">0 snapshots</div>
              <div id="history-list" class="map-list" aria-live="polite"></div>
              <div class="empty-state" id="history-empty" style="display:none;">
                <p style="margin:0 0 0.75rem;" data-empty-primary>No snapshots yet for this range.</p>
                <p style="margin:0; font-size:0.85rem;">Tip: enable location on HTTPS or use localhost for device snapshots. Otherwise, capture from the map center.</p>
              </div>
            </section>
          </aside>

          <section class="map-panel">
            <div id="map" class="map"></div>
          </section>
        </div>
      </div>
    </main>

    <div class="toast" id="toast" role="status" aria-live="polite"></div>

    <script src="./shared/storage.js"></script>
    <script src="./shared/nav-loader.js"></script>
    <script
      src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
      integrity="sha256-o9N1j7kGStpBlXnKzHf0C6YxM0tZQYVI0eCFj0zPmL0="
      crossorigin="anonymous"
      onerror="this.onerror=null;this.remove();var s=document.createElement('script');s.src='./shared/vendor/leaflet/leaflet.js';document.head.appendChild(s);"
    ></script>
    <script>
      if (typeof window.L === 'undefined') {
        document.write('<script src="./shared/vendor/leaflet/leaflet.js"><\/script>');
      }
    </script>
    <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
    <script>
      (function () {
        const toast = document.getElementById('toast');
        const myLocationBtn = document.getElementById('my-location');
        const snapshotBtn = document.getElementById('snapshot');
        const dateButton = document.getElementById('date-button');
        const dateInput = document.getElementById('date-input');
        const modeButtons = Array.from(document.querySelectorAll('.map-mode'));
        const searchInput = document.getElementById('search-note');
        const historyList = document.getElementById('history-list');
        const historyCount = document.getElementById('history-count');
        const historyEmpty = document.getElementById('history-empty');
        const historyEmptyPrimary = historyEmpty ? historyEmpty.querySelector('[data-empty-primary]') : null;
        const rangeLabel = document.getElementById('range-label');
        const exportBtn = document.getElementById('export-map');
        const importBtn = document.getElementById('import-map');
        const importFile = document.getElementById('import-file');
        const calendarPrev = document.getElementById('calendar-prev');
        const calendarNext = document.getElementById('calendar-next');
        const calendarMonth = document.getElementById('calendar-month');
        const calendarGrid = document.getElementById('calendar-grid');
        const calendarLabels = document.querySelector('.map-calendar__grid--labels');

        const DEFAULT_VIEW = [37.773972, -122.431297];
        const state = {
          mode: 'day',
          anchor: new Date(),
          search: '',
        };

        const map = L.map('map', { zoomControl: true });
        map.setView(DEFAULT_VIEW, 4);

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          attribution: '&copy; OpenStreetMap contributors',
          maxZoom: 19,
        }).addTo(map);

        let markerLayer = L.layerGroup().addTo(map);
        let markerIndex = new Map();

        renderCalendarLabels();
        refresh();
        requestAnimationFrame(() => {
          map.invalidateSize();
        });

        function renderCalendarLabels() {
          if (!calendarLabels) return;
          const labels = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
          calendarLabels.innerHTML = '';
          labels.forEach((label) => {
            const cell = document.createElement('div');
            cell.className = 'map-calendar__label';
            cell.textContent = label;
            calendarLabels.appendChild(cell);
          });
        }

        function toInputValue(value) {
          const date = value instanceof Date ? new Date(value.getTime()) : new Date(value);
          if (Number.isNaN(date.getTime())) return '';
          const offset = date.getTimezoneOffset();
          const local = new Date(date.getTime() - offset * 60000);
          return local.toISOString().slice(0, 10);
        }

        function fromInputValue(value) {
          if (!value) return new Date();
          const parts = value.split('-').map(Number);
          if (parts.length === 3 && parts.every((part) => Number.isFinite(part))) {
            return new Date(parts[0], parts[1] - 1, parts[2]);
          }
          const parsed = new Date(value);
          return Number.isNaN(parsed.getTime()) ? new Date() : parsed;
        }

        function ensureDate(value) {
          if (value instanceof Date) {
            return Number.isNaN(value.getTime()) ? new Date() : new Date(value.getTime());
          }
          return fromInputValue(String(value));
        }

        function showToast(message) {
          toast.textContent = message;
          toast.classList.add('visible');
          setTimeout(() => toast.classList.remove('visible'), 2400);
        }

        function refresh() {
          const anchor = ensureDate(state.anchor);
          state.anchor = anchor;
          dateInput.value = toInputValue(anchor);
          updateModeButtons();
          updateDateButton(anchor);
          const allLocations = StorageAPI.loadLocations();
          const { start, end } = resolveRange(state.mode, anchor);
          const searchTerm = (state.search || '').trim().toLowerCase();
          const visibleLocations = filterByRange(allLocations, start, end)
            .filter((location) => {
              if (!searchTerm) return true;
              return (location.note || '').toLowerCase().includes(searchTerm);
            })
            .sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
          if (searchInput) {
            searchInput.value = state.search;
          }
          renderMarkers(visibleLocations);
          renderList(visibleLocations);
          renderCalendar(allLocations);
          updateRangeLabel(anchor, visibleLocations.length);
          map.invalidateSize();
        }

        function updateModeButtons() {
          modeButtons.forEach((button) => {
            const { mode } = button.dataset;
            const isActive = mode === state.mode;
            button.setAttribute('aria-pressed', String(isActive));
            button.classList.toggle('is-active', isActive);
          });
        }

        function updateDateButton(anchor) {
          const label = anchor.toLocaleDateString(undefined, {
            weekday: 'long',
            month: 'long',
            day: 'numeric',
            year: 'numeric',
          });
          dateButton.setAttribute('aria-label', `Select date (currently ${label})`);
        }

        function resolveRange(mode, anchor) {
          if (mode === 'week') {
            return { start: startOfWeek(anchor), end: endOfWeek(anchor) };
          }
          if (mode === 'month') {
            return { start: startOfMonth(anchor), end: endOfMonth(anchor) };
          }
          return { start: startOfDay(anchor), end: endOfDay(anchor) };
        }

        function filterByRange(list, start, end) {
          return list.filter((location) => {
            const created = new Date(location.created_at);
            if (Number.isNaN(created.getTime())) return false;
            if (start && created < start) return false;
            if (end && created > end) return false;
            return true;
          });
        }

        function renderMarkers(locations) {
          if (markerLayer) {
            markerLayer.removeFrom(map);
          }
          const supportsClusters = typeof L.markerClusterGroup === 'function';
          markerLayer = locations.length > 100 && supportsClusters ? L.markerClusterGroup({ chunkedLoading: true }) : L.layerGroup();
          markerIndex = new Map();
          locations.forEach((location) => {
            const marker = L.marker([location.lat, location.lng]);
            marker.locationId = location.id;
            marker.bindPopup(popupContent(location));
            markerLayer.addLayer(marker);
            markerIndex.set(location.id, marker);
          });
          markerLayer.addTo(map);
          if (locations.length) {
            const bounds = L.latLngBounds(locations.map((location) => [location.lat, location.lng]));
            map.fitBounds(bounds.pad(0.2));
          } else {
            map.setView(DEFAULT_VIEW, 4);
          }
        }

        map.on('popupopen', (event) => {
          const container = event.popup.getElement();
          if (!container) return;
          const { locationId } = event.popup._source || {};
          const editBtn = container.querySelector('[data-action="edit"]');
          const deleteBtn = container.querySelector('[data-action="delete"]');
          if (editBtn) {
            editBtn.addEventListener('click', () => {
              event.popup.close();
              handleEdit(locationId);
            });
          }
          if (deleteBtn) {
            deleteBtn.addEventListener('click', () => {
              event.popup.close();
              handleDelete(locationId);
            });
          }
        });

        function popupContent(location) {
          const accuracy = location.accuracy_m != null ? `${Math.round(location.accuracy_m)} m` : '—';
          const note = location.note ? escapeHtml(location.note) : '<em>No note</em>';
          return `
            <div class="map-popup">
              <strong>${formatDate(location.created_at)}</strong><br />
              <span>Accuracy: ${accuracy}</span><br />
              <span>Source: ${location.source}</span>
              <p style="margin:0.5rem 0 0;">${note}</p>
              <div style="margin-top:0.5rem; display:flex; gap:0.5rem;">
                <button type="button" data-action="edit">Edit note</button>
                <button type="button" class="danger" data-action="delete">Delete</button>
              </div>
            </div>
          `;
        }

        function renderList(locations) {
          historyList.innerHTML = '';
          historyCount.textContent = `${locations.length} snapshot${locations.length === 1 ? '' : 's'}`;
          if (!locations.length) {
            if (historyEmptyPrimary) {
              historyEmptyPrimary.textContent = state.search ? 'No snapshots match your search.' : 'No snapshots yet for this range.';
            }
            historyEmpty.style.display = 'block';
            return;
          }
          historyEmpty.style.display = 'none';
          locations.forEach((location) => {
            const item = document.createElement('div');
            item.className = 'map-list-item';
            item.innerHTML = `
              <div class="map-list-item__meta">
                <span>${formatDate(location.created_at)}</span>
                <span class="tag">${location.source}</span>
              </div>
              <div>${location.note ? escapeHtml(location.note) : '<em style="color:var(--color-muted);">No note</em>'}</div>
              <div class="map-list-item__actions">
                <button type="button" class="ghost" data-action="focus">Focus</button>
                <button type="button" class="secondary" data-action="edit">Edit note</button>
                <button type="button" class="danger" data-action="delete">Delete</button>
              </div>
            `;
            item.querySelector('[data-action="focus"]').addEventListener('click', () => focusLocation(location));
            item.querySelector('[data-action="edit"]').addEventListener('click', () => handleEdit(location.id));
            item.querySelector('[data-action="delete"]').addEventListener('click', () => handleDelete(location.id));
            historyList.appendChild(item);
          });
        }

        function renderCalendar(allLocations) {
          if (!calendarGrid || !calendarMonth) return;
          const anchor = ensureDate(state.anchor);
          calendarMonth.textContent = anchor.toLocaleDateString(undefined, { month: 'long', year: 'numeric' });
          calendarGrid.innerHTML = '';
          const counts = new Map();
          (allLocations || []).forEach((location) => {
            const key = toInputValue(location.created_at);
            if (!key) return;
            counts.set(key, (counts.get(key) || 0) + 1);
          });
          const monthStart = startOfMonth(anchor);
          const monthEnd = endOfMonth(anchor);
          const calendarStart = startOfWeek(monthStart);
          const calendarEnd = endOfWeek(monthEnd);
          const todayKey = toInputValue(new Date());
          for (let cursor = new Date(calendarStart); cursor <= calendarEnd; cursor.setDate(cursor.getDate() + 1)) {
            const day = new Date(cursor);
            const key = toInputValue(day);
            const count = counts.get(key) || 0;
            const isCurrentMonth = day.getMonth() === anchor.getMonth();
            const isSelected = key === toInputValue(anchor);
            const isToday = key === todayKey;
            const button = document.createElement('button');
            button.type = 'button';
            button.className = 'map-calendar__day';
            if (!isCurrentMonth) button.classList.add('is-outside');
            if (isSelected) button.classList.add('is-selected');
            if (isToday) button.classList.add('is-today');
            if (count > 0) button.classList.add('has-data');
            button.dataset.date = key;
            button.setAttribute('role', 'gridcell');
            button.setAttribute('aria-pressed', String(isSelected));
            button.setAttribute('aria-label', formatCalendarAria(day, count));
            button.innerHTML = `
              <span class="map-calendar__date">${day.getDate()}</span>
              ${count > 0 ? `<span class="map-calendar__count">${count}</span>` : ''}
            `;
            calendarGrid.appendChild(button);
          }
        }

        function formatCalendarAria(date, count) {
          const label = date.toLocaleDateString(undefined, {
            weekday: 'long',
            month: 'long',
            day: 'numeric',
            year: 'numeric',
          });
          if (!count) return label;
          return `${label} (${count} snapshot${count === 1 ? '' : 's'})`;
        }

        function updateRangeLabel(anchor, count) {
          if (!rangeLabel) return;
          const modeLabel = state.mode === 'week' ? 'Week' : state.mode === 'month' ? 'Month' : 'Day';
          let detail = '';
          if (state.mode === 'week') {
            const { start, end } = resolveRange('week', anchor);
            detail = `${start.toLocaleDateString(undefined, { month: 'short', day: 'numeric' })} – ${end.toLocaleDateString(undefined, { month: 'short', day: 'numeric' })}`;
          } else if (state.mode === 'month') {
            detail = anchor.toLocaleDateString(undefined, { month: 'long', year: 'numeric' });
          } else {
            detail = anchor.toLocaleDateString(undefined, { weekday: 'long', month: 'long', day: 'numeric', year: 'numeric' });
          }
          rangeLabel.textContent = `${modeLabel} view · ${detail} · ${count} snapshot${count === 1 ? '' : 's'}`;
        }

        function focusLocation(location) {
          map.setView([location.lat, location.lng], 15);
          const marker = markerIndex.get(location.id);
          if (marker && marker.getPopup()) {
            marker.openPopup();
          }
        }

        function handleEdit(id) {
          if (!id) return;
          const locations = StorageAPI.loadLocations();
          const target = locations.find((item) => item.id === id);
          if (!target) return;
          const nextNote = window.prompt('Update note', target.note || '');
          if (nextNote == null) return;
          StorageAPI.updateLocation(id, { note: nextNote });
          refresh();
          showToast('Location updated');
        }

        function handleDelete(id) {
          if (!id) return;
          if (!window.confirm('Delete this snapshot?')) return;
          StorageAPI.deleteLocation(id);
          refresh();
          showToast('Location removed');
        }

        function requestGeolocation() {
          return new Promise((resolve, reject) => {
            if (!navigator.geolocation) {
              reject(new Error('Geolocation unavailable'));
              return;
            }
            navigator.geolocation.getCurrentPosition(resolve, reject, {
              enableHighAccuracy: true,
              timeout: 12000,
              maximumAge: 0,
            });
          });
        }

        async function captureSnapshot() {
          try {
            const position = await requestGeolocation();
            const { latitude, longitude, accuracy } = position.coords;
            const entry = StorageAPI.addLocation({
              lat: latitude,
              lng: longitude,
              accuracy_m: accuracy,
              source: 'device',
            });
            showToast('Snapshot saved');
            map.setView([entry.lat, entry.lng], 15);
            refresh();
          } catch (err) {
            console.warn('Device snapshot failed, using map center', err);
            const center = map.getCenter();
            const entry = StorageAPI.addLocation({
              lat: center.lat,
              lng: center.lng,
              source: 'manual',
            });
            showToast('Manual snapshot saved');
            map.setView([entry.lat, entry.lng], 15);
            refresh();
          }
        }

        async function goToMyLocation() {
          try {
            const position = await requestGeolocation();
            const { latitude, longitude } = position.coords;
            map.setView([latitude, longitude], 15);
            showToast('Centered on your location');
          } catch (err) {
            console.warn('Unable to fetch current position', err);
            showToast('Location unavailable, adjust map manually');
          }
        }

        function escapeHtml(text) {
          const div = document.createElement('div');
          div.textContent = text;
          return div.innerHTML;
        }

        function formatDate(value) {
          const parsed = new Date(value);
          if (Number.isNaN(parsed.getTime())) return '';
          return parsed.toLocaleString();
        }

        function startOfDay(date) {
          const d = new Date(date);
          d.setHours(0, 0, 0, 0);
          return d;
        }

        function endOfDay(date) {
          const d = new Date(date);
          d.setHours(23, 59, 59, 999);
          return d;
        }

        function startOfWeek(date) {
          const d = new Date(date);
          d.setHours(0, 0, 0, 0);
          const diff = (d.getDay() + 6) % 7;
          d.setDate(d.getDate() - diff);
          return d;
        }

        function endOfWeek(date) {
          const start = startOfWeek(date);
          const end = new Date(start);
          end.setDate(start.getDate() + 6);
          end.setHours(23, 59, 59, 999);
          return end;
        }

        function startOfMonth(date) {
          const d = new Date(date);
          d.setDate(1);
          d.setHours(0, 0, 0, 0);
          return d;
        }

        function endOfMonth(date) {
          const start = startOfMonth(date);
          const end = new Date(start);
          end.setMonth(end.getMonth() + 1);
          end.setMilliseconds(-1);
          return end;
        }

        function addMonths(date, amount) {
          const d = new Date(date);
          d.setMonth(d.getMonth() + amount);
          return d;
        }

        snapshotBtn.addEventListener('click', captureSnapshot);
        myLocationBtn.addEventListener('click', goToMyLocation);
        modeButtons.forEach((button) => {
          button.addEventListener('click', () => {
            const { mode } = button.dataset;
            if (!mode) return;
            state.mode = mode;
            refresh();
          });
        });
        if (searchInput) {
          searchInput.addEventListener('input', (event) => {
            state.search = event.target.value;
            refresh();
          });
        }
        dateButton.addEventListener('click', () => {
          if (typeof dateInput.showPicker === 'function') {
            dateInput.showPicker();
          } else {
            dateInput.focus();
            dateInput.click();
          }
        });
        dateInput.addEventListener('change', (event) => {
          state.anchor = fromInputValue(event.target.value);
          refresh();
        });
        if (calendarPrev) {
          calendarPrev.addEventListener('click', () => {
            state.anchor = addMonths(state.anchor, -1);
            refresh();
          });
        }
        if (calendarNext) {
          calendarNext.addEventListener('click', () => {
            state.anchor = addMonths(state.anchor, 1);
            refresh();
          });
        }
        if (calendarGrid) {
          calendarGrid.addEventListener('click', (event) => {
            const target = event.target.closest('button[data-date]');
            if (!target) return;
            state.anchor = fromInputValue(target.dataset.date);
            state.mode = 'day';
            refresh();
          });
        }
        exportBtn.addEventListener('click', () => {
          const data = StorageAPI.exportJson();
          const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const link = document.createElement('a');
          link.href = url;
          link.download = `health-map-${new Date().toISOString().slice(0, 10)}.json`;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          URL.revokeObjectURL(url);
          showToast('Export ready');
        });
        importBtn.addEventListener('click', () => importFile.click());
        importFile.addEventListener('change', async (event) => {
          const file = event.target.files && event.target.files[0];
          if (!file) return;
          try {
            const text = await file.text();
            const payload = JSON.parse(text);
            const result = StorageAPI.importJson(payload);
            showToast(`Import complete: events +${result.events.added}, locations +${result.locations.added}`);
          } catch (err) {
            console.error('Import failed', err);
            showToast('Import failed');
          } finally {
            event.target.value = '';
          }
        });

        window.addEventListener('health:changed', refresh);

        if ('serviceWorker' in navigator) {
          window.addEventListener('load', () => {
            navigator.serviceWorker.register('./service-worker.js').catch((err) => {
              console.warn('Service worker registration failed', err);
            });
          });
        }
      })();
    </script>
  </body>
</html>

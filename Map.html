<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Map</title>
    <link rel="stylesheet" href="./shared/styles.css" />
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
      crossorigin=""
    />
    <script
      src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
      integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
      crossorigin=""
      defer
    ></script>
  </head>
  <body class="app-shell" data-page="map">
    <div data-include="nav"></div>
    <main class="app-main">
      <div class="container flow">
        <header class="page-header">
          <span class="page-header__eyebrow">Map</span>
          <h1>Location snapshots</h1>
          <p>
            Capture quick snapshots tied to your current location, explore them on the map,
            and sync changes instantly across tabs.
          </p>
          <span class="badge">Spatial memory</span>
        </header>

        <div class="toolbar">
          <button id="btnLocate" class="btn ghost" type="button">My location</button>
          <button id="btnSnap" class="btn primary" type="button">Snapshot</button>
          <input id="inpDate" type="date" class="input" />
          <div class="chip-group" role="group" aria-label="Filter by range">
            <button class="chip active" data-scope="day" type="button">Day</button>
            <button class="chip" data-scope="week" type="button">Week</button>
            <button class="chip" data-scope="month" type="button">Month</button>
          </div>
          <input
            id="inpSearch"
            class="input search-field"
            placeholder="Search by note"
            type="search"
            aria-label="Search snapshots"
          />
          <button id="btnExport" class="btn ghost" type="button">Export JSON</button>
          <button id="btnImport" class="btn ghost" type="button">Import JSON</button>
          <input id="fileImport" type="file" accept="application/json" />
        </div>

        <div class="map-layout">
          <div id="map" class="map" aria-label="Locations map"></div>
          <aside class="panel" aria-label="Snapshot history">
            <div class="muted" style="margin-bottom: 0.5rem;">History</div>
            <ul id="list" class="list"></ul>
          </aside>
        </div>
      </div>
    </main>

    <script src="./shared/nav-loader.js" defer></script>
    <script>
      (function () {
        const LS_LOCATIONS = 'health_locations_v1';
        const nowIso = () => new Date().toISOString();
        const uuid = () =>
          (crypto.randomUUID
            ? crypto.randomUUID()
            : 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
                const r = (Math.random() * 16) | 0;
                const v = c === 'x' ? r : (r & 0x3) | 0x8;
                return v.toString(16);
              }));

        function loadLocations() {
          try {
            return JSON.parse(localStorage.getItem(LS_LOCATIONS) || '[]');
          } catch (error) {
            console.warn('Failed to parse stored locations', error);
            return [];
          }
        }

        function saveLocations(entries) {
          localStorage.setItem(LS_LOCATIONS, JSON.stringify(entries));
          window.dispatchEvent(new CustomEvent('health:changed'));
        }

        function addLocation(data) {
          const entries = loadLocations();
          const item = {
            id: uuid(),
            note: '',
            source: 'device',
            created_at: nowIso(),
            updated_at: nowIso(),
            ...data,
          };
          entries.push(item);
          saveLocations(entries);
          return item;
        }

        function updateLocation(id, patch) {
          const entries = loadLocations();
          const index = entries.findIndex((entry) => entry.id === id);
          if (index >= 0) {
            entries[index] = { ...entries[index], ...patch, updated_at: nowIso() };
            saveLocations(entries);
          }
        }

        function deleteLocation(id) {
          const next = loadLocations().filter((entry) => entry.id !== id);
          saveLocations(next);
        }

        function startOfDay(date) {
          const next = new Date(date);
          next.setHours(0, 0, 0, 0);
          return next;
        }

        function endOfDay(date) {
          const next = new Date(date);
          next.setHours(23, 59, 59, 999);
          return next;
        }

        function startOfWeek(date) {
          const next = new Date(date);
          const weekday = (next.getDay() + 6) % 7;
          next.setDate(next.getDate() - weekday);
          next.setHours(0, 0, 0, 0);
          return next;
        }

        function endOfWeek(date) {
          const next = startOfWeek(date);
          next.setDate(next.getDate() + 6);
          next.setHours(23, 59, 59, 999);
          return next;
        }

        function startOfMonth(date) {
          const next = new Date(date.getFullYear(), date.getMonth(), 1);
          next.setHours(0, 0, 0, 0);
          return next;
        }

        function endOfMonth(date) {
          const next = new Date(date.getFullYear(), date.getMonth() + 1, 0);
          next.setHours(23, 59, 59, 999);
          return next;
        }

        function rangeForScope(value, date) {
          if (value === 'day') return [startOfDay(date), endOfDay(date)];
          if (value === 'week') return [startOfWeek(date), endOfWeek(date)];
          return [startOfMonth(date), endOfMonth(date)];
        }

        let map;
        let markersLayer;
        let meMarker = null;
        let meCircle = null;
        let scope = 'day';
        let anchor = new Date();

        const elements = {
          date: document.getElementById('inpDate'),
          search: document.getElementById('inpSearch'),
          list: document.getElementById('list'),
          locate: document.getElementById('btnLocate'),
          snapshot: document.getElementById('btnSnap'),
          scopeButtons: Array.from(document.querySelectorAll('[data-scope]')),
          importInput: document.getElementById('fileImport'),
          importBtn: document.getElementById('btnImport'),
          exportBtn: document.getElementById('btnExport'),
        };

        elements.date.valueAsDate = anchor;

        function initMap() {
          const last = loadLocations().slice(-1)[0];
          const center = last ? [last.lat, last.lng] : [52.37, 4.89];
          map = L.map('map');
          map.setView(center, last ? 13 : 12);
          L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: '© OpenStreetMap',
          }).addTo(map);
          markersLayer = L.layerGroup().addTo(map);
          setTimeout(() => map.invalidateSize(), 0);
        }

        function updateCurrentPosition(lat, lng, accuracy) {
          if (!map) return;
          if (meMarker) {
            map.removeLayer(meMarker);
            meMarker = null;
          }
          if (meCircle) {
            map.removeLayer(meCircle);
            meCircle = null;
          }

          meMarker = L.circleMarker([lat, lng], {
            radius: 7,
            color: '#2563eb',
            fillColor: '#2563eb',
            fillOpacity: 1,
            weight: 2,
          }).addTo(map);

          if (typeof accuracy === 'number' && Number.isFinite(accuracy) && accuracy > 0) {
            meCircle = L.circle([lat, lng], {
              radius: accuracy,
              color: '#60a5fa',
              fillColor: '#93c5fd',
              fillOpacity: 0.15,
              weight: 1,
            }).addTo(map);
          }
        }

        function filterLocations() {
          const [start, end] = rangeForScope(scope, anchor);
          const query = (elements.search.value || '').toLowerCase().trim();
          return loadLocations().filter((entry) => {
            const time = new Date(entry.created_at).getTime();
            const inRange = time >= start.getTime() && time <= end.getTime();
            if (!inRange) return false;
            if (!query) return true;
            return (entry.note || '').toLowerCase().includes(query);
          });
        }

        function render() {
          const items = filterLocations();
          if (markersLayer) {
            markersLayer.clearLayers();

            items.forEach((entry) => {
              const marker = L.marker([entry.lat, entry.lng]).addTo(markersLayer);
              const when = new Date(entry.created_at).toLocaleString();
              marker.bindPopup(
                `<b>${when}</b><br>accuracy: ${entry.accuracy_m ?? '—'} m<br>${entry.note || ''}`
              );
            });
          }

          elements.list.innerHTML = '';
          if (!items.length) {
            const empty = document.createElement('li');
            empty.className = 'item';
            empty.innerHTML = '<span class="muted">0 snapshots</span>';
            elements.list.appendChild(empty);
            return;
          }

          items
            .slice()
            .sort((a, b) => new Date(b.created_at) - new Date(a.created_at))
            .forEach((entry) => {
              const li = document.createElement('li');
              li.className = 'item';
              const when = new Date(entry.created_at).toLocaleString();
              li.innerHTML = `
                <div>
                  <div><strong>${when}</strong></div>
                  <div class="muted">${entry.lat.toFixed(5)}, ${entry.lng.toFixed(5)} · acc ${
                entry.accuracy_m ?? '—'
              } m</div>
                  <div class="muted" contenteditable="true" data-id="${entry.id}" style="outline:none;">${
                entry.note || ''
              }</div>
                </div>
                <button class="btn ghost" data-action="focus" data-id="${entry.id}" type="button">Focus</button>
                <button class="btn" data-action="delete" data-id="${entry.id}" type="button">Delete</button>
              `;
              elements.list.appendChild(li);
            });
        }

        function focusOn(lat, lng) {
          if (map) {
            map.flyTo([lat, lng], 16);
          }
        }

        function showCurrentPosition() {
          if (!('geolocation' in navigator)) {
            alert('Geolocation is not available');
            return;
          }
          navigator.geolocation.getCurrentPosition(
            (pos) => {
              const lat = pos.coords.latitude;
              const lng = pos.coords.longitude;
              const acc = Math.round(pos.coords.accuracy || 0);
              updateCurrentPosition(lat, lng, acc);
              focusOn(lat, lng);
            },
            (error) => {
              alert('Geolocation error: ' + error.message);
            },
            { enableHighAccuracy: true, maximumAge: 5000, timeout: 15000 }
          );
        }

        function snapshotFrom(lat, lng, accuracy, source) {
          const item = addLocation({ lat, lng, accuracy_m: accuracy, source });
          if (markersLayer) {
            L.marker([item.lat, item.lng]).addTo(markersLayer);
          }
          focusOn(item.lat, item.lng);
          render();
        }

        function snapshotFromCenter() {
          const center = map?.getCenter();
          if (!center) return;
          snapshotFrom(center.lat, center.lng, null, 'manual');
        }

        function snapshot() {
          if (!('geolocation' in navigator)) {
            snapshotFromCenter();
            return;
          }
          navigator.geolocation.getCurrentPosition(
            (pos) => {
              const lat = pos.coords.latitude;
              const lng = pos.coords.longitude;
              const acc = Math.round(pos.coords.accuracy || 0);
              updateCurrentPosition(lat, lng, acc);
              snapshotFrom(lat, lng, acc, 'device');
            },
            () => snapshotFromCenter(),
            { enableHighAccuracy: true, maximumAge: 5000, timeout: 8000 }
          );
        }

        elements.locate?.addEventListener('click', showCurrentPosition);
        elements.snapshot?.addEventListener('click', snapshot);

        elements.date.addEventListener('change', () => {
          anchor = elements.date.valueAsDate || new Date();
          render();
        });

        elements.scopeButtons.forEach((button) => {
          button.addEventListener('click', () => {
            scope = button.dataset.scope;
            elements.scopeButtons.forEach((item) =>
              item.classList.toggle('active', item.dataset.scope === scope)
            );
            render();
          });
        });

        elements.search.addEventListener('input', () => render());

        elements.list.addEventListener('click', (event) => {
          const target = event.target;
          if (!(target instanceof HTMLElement)) return;
          const { action, id } = target.dataset;
          if (!id) return;
          if (action === 'delete') {
            deleteLocation(id);
            render();
          }
          if (action === 'focus') {
            const item = loadLocations().find((entry) => entry.id === id);
            if (item) {
              focusOn(item.lat, item.lng);
            }
          }
        });

        elements.list.addEventListener('focusout', (event) => {
          const target = event.target;
          if (!(target instanceof HTMLElement)) return;
          const id = target.dataset.id;
          if (!id) return;
          updateLocation(id, { note: target.innerText.trim() });
          render();
        });

        elements.exportBtn.addEventListener('click', () => {
          const data = { version: 1, locations: loadLocations() };
          const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const anchorEl = document.createElement('a');
          anchorEl.href = url;
          anchorEl.download = `locations_${new Date().toISOString().slice(0, 10)}.json`;
          anchorEl.click();
          URL.revokeObjectURL(url);
        });

        elements.importBtn.addEventListener('click', () => elements.importInput.click());

        elements.importInput.addEventListener('change', async (event) => {
          const file = event.target.files?.[0];
          if (!file) return;
          const text = await file.text();
          try {
            const incoming = JSON.parse(text).locations || [];
            const current = new Map(loadLocations().map((entry) => [entry.id, entry]));
            incoming.forEach((entry) => {
              const existing = current.get(entry.id);
              if (!existing || new Date(entry.updated_at) > new Date(existing.updated_at)) {
                current.set(entry.id, entry);
              }
            });
            saveLocations([...current.values()]);
            render();
            alert(`Imported ${incoming.length} snapshots`);
          } catch (error) {
            alert('Invalid JSON');
          }
          event.target.value = '';
        });

        window.addEventListener('storage', (event) => {
          if (event.key === LS_LOCATIONS) {
            render();
          }
        });
        window.addEventListener('health:changed', render);

        function bootstrap() {
          if (typeof L === 'undefined') {
            requestAnimationFrame(bootstrap);
            return;
          }
          initMap();
          render();
        }

        bootstrap();
      })();
    </script>
  </body>
</html>
